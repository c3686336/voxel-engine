#version 450 core
#extension GL_ARB_shading_language_include : require

const int N_NEIGHBORS = 2;
const int TAXI_RADIUS = 10;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 1) writeonly uniform image2D out_img;

#include "common.comp"

const float confidence_weight = 15.0;

void main() {
    // TODO: Account for camera and object movement

    Sample current = pixel_sample[global_index];

    if (current.W == 0.0) {
        imageStore(out_img, tcoord, textureLod(skybox, current.path[1].xyz, 0.0));
        return;
    }

    float mis_canonical = 0.0;
    Reservoir r = new_reservoir();

    float p11 = current.sample_phat;

    float Mm1 = float(N_NEIGHBORS);
    const float M = Mm1 + 1.0;

    // Spatial reuse
    // TODO: parallelize this
    for (int i = 0; i < N_NEIGHBORS; i++) {
        uint neighbor_x_min = max(int(gl_GlobalInvocationID.x) - TAXI_RADIUS, 0);
        uint neighbor_x_max = min(neighbor_x_min + 2 * TAXI_RADIUS, width - 1);
        neighbor_x_min = neighbor_x_max - 2 * TAXI_RADIUS;

        uint neighbor_y_min = max(int(gl_GlobalInvocationID.y) - TAXI_RADIUS, 0);
        uint neighbor_y_max = min(neighbor_y_min + 2 * TAXI_RADIUS, height - 1);
        neighbor_y_min = neighbor_y_max - 2 * TAXI_RADIUS;

        uvec2 offset = uvec2(randv2() * 2.0 * float(TAXI_RADIUS));

        uvec2 sample_pos = uvec2(neighbor_x_min, neighbor_y_min) + offset;
        uint sample_index = sample_pos.y * width + sample_pos.x;

        Sample neighbor = pixel_sample[sample_index];

        bool invalid = neighbor.path[1].w == 0.0 || isnan(neighbor.W) || isinf(neighbor.W) || neighbor.W == 0.0;

        float p1x = phat_shift(
                neighbor, current,
                m_albedo.xyz,
                m_roughness,
                m_metallicity
            ); // phat on current domain, towards neighbor's sample
        // Valid on invalid neighbor

        float pix = neighbor.sample_phat;
        // Valid on invalid neighbor

        float pi1 = invalid ? 0.0 : phat_shift(
                current, neighbor,
                m_albedo.xyz,
                m_roughness,
                m_metallicity
            ); // phat on neighbor's domain, towards current sample
        // Invalid on invalid neighbor

        float m = pix / (p1x / Mm1 + pix) / Mm1; // pairwise mis

        float w = invalid ? 0.0 : m * p1x * neighbor.W;

        // Shift
        vec3 neighbor_viewdir = neighbor.view_dir[1];
        vec4 neighbor_path = neighbor.path[2];
        neighbor = current;
        neighbor.view_dir[1] = neighbor_viewdir;
        neighbor.path[2] = neighbor_path;
        neighbor.sample_phat = p1x;
        neighbor.W = neighbor.W;

        updateR(r, neighbor, w);

        mis_canonical += p11 / (p11 / Mm1 + pi1) / Mm1;
    }

    mis_canonical /= Mm1;

    updateR(r, current, mis_canonical * p11 * current.W);

    current = r.sample_chosen;
    current.W = r.total_weight / current.sample_phat;

    Sample temporal = prev_pixel_sample[global_index];

    Sample s = current;
    if (is_first_frame || !t_reuse || temporal.path[1].w == 0.0 || dot(temporal.normal[0], current.normal[0]) < 0.5 || isnan(temporal.W) || isinf(temporal.W)) {
    } else {
        // Temporal reuse
        // TODO: Incorporate motion vector

        Mm1 = 1.0;

        const float p1x = phat_shift(
            temporal, current,
            m_albedo.xyz,
            m_roughness,
            m_metallicity
            );

        const float pix = temporal.sample_phat;

        const float pi1 = phat_shift(
            current, temporal,
            m_albedo.xyz,
            m_roughness,
            m_metallicity
            );

        const float m = pix * confidence_weight / (p1x + pix * confidence_weight);
        const float w = m * p1x * temporal.W;

        vec3 temporal_viewdir = temporal.view_dir[1];
        vec4 temporal_path = temporal.path[2];
        temporal = current;
        temporal.view_dir[1] = temporal_viewdir;
        temporal.path[2] = temporal_path;
        temporal.sample_phat = p1x;

        r = Reservoir(temporal, w);

        {
            float m = current.sample_phat / (current.sample_phat + pi1 * confidence_weight);
            updateR(r, current, m * current.sample_phat * current.W);
        }

        s = r.sample_chosen;
        s.W = r.total_weight / (s .sample_phat);    
    }

    prev_pixel_sample[global_index] = s;

    if (d_normal) {
        imageStore(out_img, tcoord, vec4(s.normal[0], 1.0));
        return;
    }
    if (d_pos) {
        imageStore(out_img, tcoord, vec4(s.path[2].xyz, 1.0));
        return;
    }
    if (d_weight) {
        float weight = tanh(s.W) / 2.0 + 0.5;
        imageStore(out_img, tcoord, vec4(weight, weight, weight, 1.0));
        return;
    }
    if (d_show_shadow) {
        vec4 frag_color = vec4(0.0);
        vec2 frag_pos = vec2(gl_GlobalInvocationID.xy) / vec2(width, height) * 2.0 - 1.0;

        vec4 cam_ray_origin = vec4(camera_pos, 1.0);
        vec4 cam_ray_dir = normalize(vec4(frag_pos.x * camera_right + frag_pos.y * camera_up + camera_dir, 0.0));

        bool result = trace_shadow(
                cam_ray_origin, cam_ray_dir
            );

        imageStore(out_img, tcoord, result ? vec4(1.0) : vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    bool shadow_result = trace_shadow(
            s.path[1] + surface_bias_amt * vec4(s.normal[0], 0.0), vec4(-s.view_dir[1], 0.0)
        ) && (!d_shadow);

    s.W = shadow_result ? 0.0 : s.W;
    s.sample_phat = shadow_result ? 0.0 : s.sample_phat;

    vec3 frag_color =
        s.W * textureLod(skybox, -s.view_dir[1], 0.0).rgb * brdf(
                s.normal[0],
                s.view_dir[0],
                -s.view_dir[1],
                m_albedo.xyz,
                m_roughness,
                m_metallicity
            );

    imageStore(out_img, tcoord, vec4(frag_color, 1.0));
}
