#version 450 core
#extension GL_ARB_shading_language_include : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 1) readonly uniform image2D in_img;

#include "common.comp"

void main() {
    Sample s = pixel_sample[global_index];

    if (s.path[1].w == 0.0) {
        s.path[2] = s.path[1];
        pixel_sample[global_index] = s;

        return;
    }

    vec3 dir;
    float sample_weight;
    sample_hemisphere(s.normal[0], dir, sample_weight);

    s.path[2] = vec4(dir, 0.0);
    s.view_dir[1] = -dir;
    s.W = sample_weight;

    float m = 1.0 / float(n_samples);
    float sample_phat = phat(
            s,
            m_albedo.xyz,
            m_roughness,
            m_metallicity
        );

    s.sample_phat = sample_phat;
    Reservoir r = Reservoir(s, m * s.W * sample_phat);

    for (int i = 0; i < n_samples - 1; i++) {
        vec3 dir;
        float sample_weight;
        sample_hemisphere(s.normal[0], dir, sample_weight);

        s.path[2] = vec4(dir, 0.0);
        s.view_dir[1] = -dir;
        s.W = sample_weight;

        float m = 1.0 / float(n_samples);
        float sample_phat = phat(
                s,
                m_albedo.xyz,
                m_roughness,
                m_metallicity
            );

        s.sample_phat = sample_phat;

        updateR(r, s, m * s.W * sample_phat);
    }

    s = r.sample_chosen;
    s.W = r.total_weight / s.sample_phat;

    // Visibility reuse
    if (v_reuse) {
        bool shadow_result = trace_shadow(
                s.path[2] + surface_bias_amt * vec4(s.normal[0], 0.0), vec4(-s.view_dir[1], 0.0)
            ) && !d_shadow;

        s.W = shadow_result ? 0.0 : s.W;
        s.sample_phat = shadow_result ? 0.0 : s.sample_phat;
    }

    pixel_sample[global_index] = s;
}
