#version 450 core
#extension GL_ARB_shading_language_include : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 1) writeonly uniform image2D out_img;

#include "common.comp"

void main() {
    Sample s = pixel_sample[global_index];
    prev_pixel_sample[global_index] = s;

    if (s.path[1].w == 0.0) {
        imageStore(out_img, tcoord, textureLod(skybox, s.path[1].xyz, 0.0));
        return;
    }

    if (d_normal) {
        imageStore(out_img, tcoord, vec4(s.normal[0], 1.0));
        return;
    }
    if (d_pos) {
        imageStore(out_img, tcoord, vec4(s.path[2].xyz, 1.0));
        return;
    }
    if (d_weight) {
        float weight = tanh(s.W) / 2.0 + 0.5;
        imageStore(out_img, tcoord, vec4(weight, weight, weight, 1.0));
        return;
    }
    if (d_show_shadow) {
        vec4 frag_color = vec4(0.0);
        vec2 frag_pos = vec2(gl_GlobalInvocationID.xy) / vec2(width, height) * 2.0 - 1.0;

        vec4 cam_ray_origin = vec4(camera_pos, 1.0);
        vec4 cam_ray_dir = normalize(vec4(frag_pos.x * camera_right + frag_pos.y * camera_up + camera_dir, 0.0));

        bool result = trace_shadow(
                cam_ray_origin, cam_ray_dir
            );

        imageStore(out_img, tcoord, result ? vec4(1.0) : vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    bool shadow_result = trace_shadow(
            s.path[1] + surface_bias_amt * vec4(s.normal[0], 0.0), vec4(-s.view_dir[1], 0.0)
        ) && (!d_shadow);

    s.W = shadow_result ? 0.0 : s.W;
    s.sample_phat = shadow_result ? 0.0 : s.sample_phat;

    vec3 frag_color =
        s.W * textureLod(skybox, -s.view_dir[1], 0.0).rgb * brdf(
                s.normal[0],
                s.view_dir[0],
                -s.view_dir[1],
                m_albedo.xyz,
                m_roughness,
                m_metallicity
            );

    imageStore(out_img, tcoord, vec4(frag_color, 1.0));
}
